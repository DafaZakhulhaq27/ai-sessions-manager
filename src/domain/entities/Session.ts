
import { Message } from '@/src/domain/entities/Message';

export class Session {
    constructor(
        public readonly id: string,
        public title: string,
        public readonly createdAt: Date,
        public updatedAt: Date,
        private _messages: Message[] = []
    ) { }

    get messages(): ReadonlyArray<Message> {
        return this._messages;
    }

    addMessage(message: Message): void {
        this._messages.push(message);
        this.updatedAt = new Date();
    }

    updateTitle(newTitle: string): void {
        this.title = newTitle;
        this.updatedAt = new Date();
    }

    // Factory method for creating a new session
    static create(title: string): Session {
        const now = new Date();
        // ID generation should ideally be handled by a service or repo, 
        // but for simplicity in the entity, we can assign a placeholder or generate here if we use UUIDs.
        // For now, we'll let the repository handle ID generation or pass it in.
        // Let's assume the ID is passed in or generated by the caller (UseCase).
        return new Session(
            crypto.randomUUID(),
            title,
            now,
            now
        );
    }

    // Reconstitute from persistence
    static restore(
        id: string,
        title: string,
        createdAt: Date,
        updatedAt: Date,
        messages: Message[] = []
    ): Session {
        return new Session(id, title, createdAt, updatedAt, messages);
    }
}
